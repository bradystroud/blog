---
canonicalUrl: "https://bradystroud.dev/blogs/aspire-windows-vm-part-2"
title: "Running .NET Aspire from a Windows VM Using macOS Docker – Part 2: Hardening & Port Strategy"
date: 2025-09-29T00:00:00.000Z
tags:
  - dotnet
  - aspire
  - docker
  - macos
  - windows
  - parallels
  - networking
  - devops
coverImage: null
---

> This is the canonical guide. **Part 1** is optional historical context (the journey + motivation). If you just want the right, hardened process—stay here. Skim **[Part 1](./aspire-windows-vm-using-mac-docker)** only if you care about the backstory.

# Part 2: Hardening & Port Strategy for Remote Docker + Aspire

Part 1 showed how to drive Docker on the Mac host from a Windows VM for .NET Aspire (especially when you need Windows-only .NET Framework/legacy pieces). This follow-up goes deeper into:

- Making SSH + Docker context robust and passwordless
- Avoiding stray shell output that breaks `docker system dial-stdio`
- Strategies for accessing containerized services from the VM (tunneling vs publishing)
- Generic patterns for database & storage emulator endpoints
- Diagnostics you can rely on every time

None of the examples below use real project ports; substitute the placeholders with what your services actually expose.

---

## 1. Recap: Minimal Docker Context (VM → Mac)

From the Windows VM (PowerShell):

```powershell
# (Re)create or switch
docker context rm mac -f 2>$null
docker context create mac --docker "host=ssh://<user>@<mac-host>"
docker context use mac

# Sanity
docker --context mac info
docker --context mac ps
```

Diagnostics (should reflect Mac host):
```powershell
docker info
docker ps
```

---

## 2. SSH & PATH Reliability (macOS)

On macOS host:

1. Enable Remote Login: System Settings → General → Sharing → Remote Login → ON
2. Ensure Docker CLI is found by non-interactive shells:

```bash
echo 'export PATH="/usr/local/bin:/opt/homebrew/bin:$PATH"' >> ~/.zshenv
```

3. From VM verify:

```powershell
ssh <user>@<mac-host> "command -v docker && docker version --format '{{.Server.Version}}'"
```

Diagnostics:
```bash
systemsetup -getremotelogin   # Should say: Remote Login: On
whoami                        # Expected short username
sudo lsof -iTCP:22 -sTCP:LISTEN | grep sshd  # Confirms SSHD
```
From VM:
```powershell
Test-NetConnection <mac-host> -Port 22
```

---

## 3. Passwordless SSH (Required for Smooth Aspire Spins)

Aspire (and tooling like orchestrators or scripts) should not be blocked by password prompts.

On Windows VM:

```powershell
ssh-keygen -t ed25519 -C "vm-to-mac" -f "$HOME\.ssh\vm-mac"
# Append public key to authorized_keys on Mac
type $HOME\.ssh\vm-mac.pub | ssh <user>@<mac-host> "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys"
```

Test:
```powershell
ssh <user>@<mac-host>   # Should NOT prompt for a password
```

---

## 4. Ensuring a Clean SSH Session (docker system dial-stdio)

Some Docker features (and occasionally Aspire internals) rely on a clean control channel. Any banner, MOTD, or stray echo in shell init files can break the stream.

Test for cleanliness:
```bash
ssh -T <user>@<mac-host> docker system dial-stdio
```
The command should appear to hang silently (Ctrl + C to exit). If you see text output first, remove or guard that output in `~/.zprofile`, `~/.zshrc`, etc. Use conditionals like:

```bash
# In shell init files
[[ $- == *i* ]] || return 0  # Only continue for interactive shells
```

---

## 5. Accessing Container Services: Two Generic Patterns

You have two safe, generic options for the VM to reach services (DBs, storage emulators, caches) running on the Mac host Docker daemon.

### Option A: SSH Port Forwarding (Ephemeral / Local Development)

Good when you don’t want to alter compose/Aspire endpoint publishing yet.

Example pattern (replace placeholders):
```powershell
# Forward a database service
ssh -N -L <vm-port>:127.0.0.1:<container-bound-host-port> <user>@<mac-host>
# e.g., ssh -N -L 5432:127.0.0.1:5432 <user>@<mac-host>
```

You can run multiple forwards in separate terminals (or use a script).

Validation from VM:
```powershell
Test-NetConnection localhost -Port <vm-port>
```

### Option B: Publish to All Interfaces (Persistent)

Configure your Aspire container endpoints (or compose) so they bind on the host’s 0.0.0.0, letting the VM access them over the Mac host’s LAN / shared network IP.

Pseudo-code in an Aspire `AppHost` configuration (C#):

```csharp
// Pseudo / illustrative only
var db = builder.AddContainer("database", image: "postgres:latest");
// Publish host port 5432 -> container 5432 (not proxied so it's bound directly)
db.WithEndpoint(name: "tcp", port: 5432, targetPort: 5432, isProxied: false);

var cache = builder.AddContainer("cache", image: "redis:alpine");
cache.WithEndpoint(name: "tcp", port: 6379, targetPort: 6379, isProxied: false);
```

Result (conceptually) in `docker ps` Ports column:
```
0.0.0.0:5432->5432/tcp
0.0.0.0:6379->6379/tcp
```

VM validation:
```powershell
Test-NetConnection <mac-host> -Port 5432
Test-NetConnection <mac-host> -Port 6379
```

Choose Option A when experimenting or avoiding port collisions; Option B when you want a stable, team-shareable layout.

---

## 6. Generic Diagnostics Toolbox

Mac host:
```bash
docker ps --format 'table {{.Names}}\t{{.Ports}}'
lsof -nP -iTCP -sTCP:LISTEN | grep -E '(:5432|:6379)'  # adjust to the ports you published
```

Windows VM (context-aware + network reachability):
```powershell
docker --context mac info
docker --context mac ps
Test-NetConnection <mac-host> -Port 22
Test-NetConnection <mac-host> -Port 5432
Test-NetConnection <mac-host> -Port 6379
Test-NetConnection localhost -Port 5432   # if forwarding with Option A
```

If using multiple forwards (e.g., storage emulator ports), test each mapped port the same way.

---

## 7. Troubleshooting Patterns

| Symptom | Cause | Resolution |
| ------- | ----- | ---------- |
| Port forward closes unexpectedly | SSH session idle / terminal closed | Use autossh or a background task scheduler |
| Service unreachable via host IP | Endpoint only bound to 127.0.0.1 | Republish with isProxied: false / proper bind |
| docker logs shows permission errors | Key not loaded / wrong user | Re-test bare SSH and fix permissions (chmod 600) |
| `docker system dial-stdio` prints text then fails | Shell init noise | Guard init scripts for non-interactive shells |
| VM DNS resolves but connect fails | Firewall or network mode | Try Bridged or confirm sharing rules |

---

## 8. Security Considerations

- Restrict SSH to key-based auth; disable passwords if possible.
- Avoid over-publishing sensitive ports; prefer local forwards for databases in early dev.
- Rotate or revoke keys when decommissioning a VM.
- Keep Docker Desktop and the host OS patched.

---

## 9. Quick Sanity Script Idea (Pseudo)

You can author a small PowerShell script to assert environment health:

```powershell
$HostName = '<mac-host>'
$Ports = 22,5432,6379

Write-Host 'Docker context:' (docker context show)
foreach ($p in $Ports) {
  $r = Test-NetConnection $HostName -Port $p -WarningAction SilentlyContinue
  Write-Host "Port $p reachable: $($r.TcpTestSucceeded)"
}
```

Extend with: verifying `docker --context mac ps` contains expected container names.

---

## 10. When to Refactor Ports

- Collisions: Another service already binds the host port → use forwarding until you consolidate.
- Scaling: Many microservices → prefer a documented port map file or central config.
- Team Onboarding: Standardize published ports so teammates can script health checks.
- Security Shift: Move sensitive stores back to SSH forwarding if exposure not needed.

---

### Back to Part 1

Return to **[Part 1 – Running .NET Aspire in a Windows VM While Using Docker on the Mac Host](./aspire-windows-vm-using-mac-docker)** for the problem statement, architecture rationale, and initial setup steps.
